<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GRAPES: chunkbuffer.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GRAPES
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">chunkbuffer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the chunk buffer of the peer.  
<a href="#details">More...</a></p>

<p><a href="chunkbuffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="chunkbuffer_8h.html#af447ce9b27effdbbbd8c99b41d6575ab">E_CB_OLD</a>&#160;&#160;&#160;-1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="chunkbuffer_8h.html#a48f345b0fd8ecc14cc88e2758463b0b7">E_CB_DUPLICATE</a>&#160;&#160;&#160;-2</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct chunk_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="chunkbuffer_8h.html#a8f631cb3d6c674424777c403d8cfdd06">ChunkBuffer</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct chunk_buffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="chunkbuffer_8h.html#ad247036395da2108fd403dbe59acc435">cb_init</a> (const char *config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="chunkbuffer_8h.html#a906a6c08bab51a967c7d130cb4e5e0ed">cb_add_chunk</a> (struct chunk_buffer *cb, const struct <a class="el" href="structchunk.html">chunk</a> *c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structchunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="chunkbuffer_8h.html#a71be48a587f5e5af970eac183e387ba8">cb_get_chunks</a> (const struct chunk_buffer *cb, int *n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="chunkbuffer_8h.html#afae0f3d01e11cd9903d0c95deb6721c2">cb_clear</a> (struct chunk_buffer *cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="chunkbuffer_8h.html#a9fcc31ade4324bb399a5bc310f8bf574">cb_destroy</a> (struct chunk_buffer *cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structchunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="chunkbuffer_8h.html#a45358c3053a2c989e11490e224961c47">cb_get_chunk</a> (const struct chunk_buffer *cb, int id)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This is the chunk buffer of the peer. </p>
<p>The chunks buffer is responsible for storing the chunks received by a peer. Each chunk is stored until the chunk buffer decides to discard it (for example, when some kind of playout delay is expired), then it is removed from the buffer. The buffer makes its chunks available to the output module and to the scheduler, in form of an ordered list (chunks are ordered by timestamp). Since every chunk has a timestamp and a sequence number (the chunk ID), the chunk buffer's clients (scheduler and output module) can easily check if there are gaps in the list. See <a class="el" href="cb_test_8c-example.html">cb_test.c </a> for an usage example </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a48f345b0fd8ecc14cc88e2758463b0b7"></a><!-- doxytag: member="chunkbuffer.h::E_CB_DUPLICATE" ref="a48f345b0fd8ecc14cc88e2758463b0b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="chunkbuffer_8h.html#a48f345b0fd8ecc14cc88e2758463b0b7">E_CB_DUPLICATE</a>&#160;&#160;&#160;-2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The chunk is already in the buffer </p>

</div>
</div>
<a class="anchor" id="af447ce9b27effdbbbd8c99b41d6575ab"></a><!-- doxytag: member="chunkbuffer.h::E_CB_OLD" ref="af447ce9b27effdbbbd8c99b41d6575ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="chunkbuffer_8h.html#af447ce9b27effdbbbd8c99b41d6575ab">E_CB_OLD</a>&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The chunk is too old </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a8f631cb3d6c674424777c403d8cfdd06"></a><!-- doxytag: member="chunkbuffer.h::ChunkBuffer" ref="a8f631cb3d6c674424777c403d8cfdd06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct chunk_buffer <a class="el" href="chunkbuffer_8h.html#a8f631cb3d6c674424777c403d8cfdd06">ChunkBuffer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Structure describing a chunk buffer. This is an opaque type. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a906a6c08bab51a967c7d130cb4e5e0ed"></a><!-- doxytag: member="chunkbuffer.h::cb_add_chunk" ref="a906a6c08bab51a967c7d130cb4e5e0ed" args="(struct chunk_buffer *cb, const struct chunk *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="chunkbuffer_8h.html#a906a6c08bab51a967c7d130cb4e5e0ed">cb_add_chunk</a> </td>
          <td>(</td>
          <td class="paramtype">struct chunk_buffer *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structchunk.html">chunk</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a chunk to a buffer.</p>
<p>Insert a chunk in the given buffer. One or more chunks can be removed from the buffer (if necessary, and according to the internal logic of the chunk buffer) to create space for the new one.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>a pointer to the chunk buffer </td></tr>
    <tr><td class="paramname">c</td><td>a pointer to the descriptor of the chunk to be inserted in the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&gt;=0 in case of success, &lt; 0 in case of failure </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cb_test_8c-example.html#a7">cb_test.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afae0f3d01e11cd9903d0c95deb6721c2"></a><!-- doxytag: member="chunkbuffer.h::cb_clear" ref="afae0f3d01e11cd9903d0c95deb6721c2" args="(struct chunk_buffer *cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="chunkbuffer_8h.html#afae0f3d01e11cd9903d0c95deb6721c2">cb_clear</a> </td>
          <td>(</td>
          <td class="paramtype">struct chunk_buffer *&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear a chunk buffer</p>
<p>Remove all the chunks from the specified chunk buffer.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>a pointer to the chunk buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&gt;= 0 in case of success, &lt; 0 in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fcc31ade4324bb399a5bc310f8bf574"></a><!-- doxytag: member="chunkbuffer.h::cb_destroy" ref="a9fcc31ade4324bb399a5bc310f8bf574" args="(struct chunk_buffer *cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="chunkbuffer_8h.html#a9fcc31ade4324bb399a5bc310f8bf574">cb_destroy</a> </td>
          <td>(</td>
          <td class="paramtype">struct chunk_buffer *&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy a chunk buffer</p>
<p>Remove all the chunks from the specified chunk buffer, and free all the memory dynamically allocated to it.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>a pointer to the chunk buffer </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cb_test_8c-example.html#a10">cb_test.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a45358c3053a2c989e11490e224961c47"></a><!-- doxytag: member="chunkbuffer.h::cb_get_chunk" ref="a45358c3053a2c989e11490e224961c47" args="(const struct chunk_buffer *cb, int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structchunk.html">chunk</a>* <a class="el" href="chunkbuffer_8h.html#a45358c3053a2c989e11490e224961c47">cb_get_chunk</a> </td>
          <td>(</td>
          <td class="paramtype">const struct chunk_buffer *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a specific chunk from a buffer</p>
<p>Provide one single chunk from the specified chunkbuffer, with the requested identifier.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>a pointer to the chunk buffer </td></tr>
    <tr><td class="paramname">id</td><td>the identifier of the chunk to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the requested chunk </dd></dl>

</div>
</div>
<a class="anchor" id="a71be48a587f5e5af970eac183e387ba8"></a><!-- doxytag: member="chunkbuffer.h::cb_get_chunks" ref="a71be48a587f5e5af970eac183e387ba8" args="(const struct chunk_buffer *cb, int *n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structchunk.html">chunk</a>* <a class="el" href="chunkbuffer_8h.html#a71be48a587f5e5af970eac183e387ba8">cb_get_chunks</a> </td>
          <td>(</td>
          <td class="paramtype">const struct chunk_buffer *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the chunks from a buffer.</p>
<p>Provide an (ordered) list of the chunks which are currently stored in the specified chunk buffer. Such list is stored in a C arrary (so, after calling chunks_array = cb_get_chunks(cb), chunks_array[i] contains the i^th chunk). Chunks are ordered by increasing chunk ID.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>a pointer to the chunks buffer </td></tr>
    <tr><td class="paramname">n</td><td>a pointer to an integer variable where number of chunks will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the chunks array if there are no failures and the buffer is not empty, NULL if the buffer is empty or in case of error (in case of error, n &lt; 0; if the buffer is empty, n = 0). </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cb_test_8c-example.html#a8">cb_test.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad247036395da2108fd403dbe59acc435"></a><!-- doxytag: member="chunkbuffer.h::cb_init" ref="ad247036395da2108fd403dbe59acc435" args="(const char *config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct chunk_buffer* <a class="el" href="chunkbuffer_8h.html#ad247036395da2108fd403dbe59acc435">cb_init</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a chunk buffer.</p>
<p>Allocate and initialise a chunk buffer structure, and return a pointer to it.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>a text string containing some configuration parameters for the buffer, such as the playout delay and maybe some additional parameters (estimated size of the buffer, etc...) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the allocated chunk buffer in case of success, NULL otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cb_test_8c-example.html#a9">cb_test.c</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri May 3 2013 10:18:23 for GRAPES by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
