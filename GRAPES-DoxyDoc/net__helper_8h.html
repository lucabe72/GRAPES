<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GRAPES: net_helper.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GRAPES
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">net_helper.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Communication facility interface for SOM.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sys/time.h&gt;</code><br/>
</div>
<p><a href="net__helper_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct nodeID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#ae8352797e9259af14c53a651feaab2cd">nodeid_dup</a> (struct nodeID *s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a nodeID.  <a href="#ae8352797e9259af14c53a651feaab2cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#a7191fee44ddba7c8421673a4a2be7659">nodeid_equal</a> (const struct nodeID *s1, const struct nodeID *s2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if two nodes are identical.  <a href="#a7191fee44ddba7c8421673a4a2be7659"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#aaf5dae2ffb81eb6605c97c8f57af3e22">nodeid_cmp</a> (const struct nodeID *s1, const struct nodeID *s2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two nodes and give some consistent ordering. This ordering should only be used for keeping lists ordered, it has no other meaning.  <a href="#aaf5dae2ffb81eb6605c97c8f57af3e22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct nodeID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#a9dd12dbdb263ed41b6fd849e1b7e0e2d">create_node</a> (const char *IPaddr, int port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new nodeID.  <a href="#a9dd12dbdb263ed41b6fd849e1b7e0e2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#acbb39cd9f02b80f55cb9b4956f4d7e90">nodeid_free</a> (struct nodeID *s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a nodeID.  <a href="#acbb39cd9f02b80f55cb9b4956f4d7e90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct nodeID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#a75c24f68a227ceca874aee06e35aef6f">net_helper_init</a> (const char *IPaddr, int port, const char *config)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all needed internal parameters.  <a href="#a75c24f68a227ceca874aee06e35aef6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#a8286f963d31419ef052f8d514628271c">bind_msg_type</a> (uint8_t msgtype)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare to receive messages of the specified type.  <a href="#a8286f963d31419ef052f8d514628271c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#adcdbaaa4ea0b0e78c6769f928568f488">send_to_peer</a> (const struct nodeID *from, struct nodeID *to, const uint8_t *buffer_ptr, int buffer_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to a remote peer.  <a href="#adcdbaaa4ea0b0e78c6769f928568f488"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#a6a7b9f1b75209bb621e03b6bb64dbcac">recv_from_peer</a> (const struct nodeID *local, struct nodeID **remote, uint8_t *buffer_ptr, int buffer_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from a remote peer.  <a href="#a6a7b9f1b75209bb621e03b6bb64dbcac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#aba639b19170daf84c4b84e8f59eba6a3">wait4data</a> (const struct nodeID *n, struct timeval *tout, int *user_fds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for newly arrived data.  <a href="#aba639b19170daf84c4b84e8f59eba6a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#ad05d8fbd0811dd9cd8b9f527cc39e2fc">node_addr</a> (const struct nodeID *s, char *addr, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a string representation of a nodeID.  <a href="#ad05d8fbd0811dd9cd8b9f527cc39e2fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct nodeID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#ae3226bc9eb04a11867d8b5a03a0389eb">nodeid_undump</a> (const uint8_t *b, int *len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a nodeID structure from a serialized object.  <a href="#ae3226bc9eb04a11867d8b5a03a0389eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#a92f4aa022ecb8b3d698da7d138fc64ad">nodeid_dump</a> (uint8_t *b, const struct nodeID *s, size_t max_write_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a nodeID in a byte array.  <a href="#a92f4aa022ecb8b3d698da7d138fc64ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#ab16ff836fbed959c3030044d2310c43f">node_ip</a> (const struct nodeID *s, char *ip, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a string representation of the public IP belonging to the nodeID.  <a href="#ab16ff836fbed959c3030044d2310c43f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__helper_8h.html#aa73adc34be2bbccd9db18cb0b9aff4b7">node_port</a> (const struct nodeID *s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the port number associated to the nodeID.  <a href="#aa73adc34be2bbccd9db18cb0b9aff4b7"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Communication facility interface for SOM. </p>
<p>A clean interface is provided, through which all the communication procedures needed by SOM functions are handled. This way the different SOM functionalities are not dependent on any particular library with respect of the way they may call or be called by other applicative components. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8286f963d31419ef052f8d514628271c"></a><!-- doxytag: member="net_helper.h::bind_msg_type" ref="a8286f963d31419ef052f8d514628271c" args="(uint8_t msgtype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="net__helper_8h.html#a8286f963d31419ef052f8d514628271c">bind_msg_type</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare to receive messages of the specified type. </p>
<p>Depending on the networking protocols and technologies used by the net helper, the application might need to declare the types of messages it's interested in. This function allows to specify which messages should be received (messages of different types might be silently discarded). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgtype</td><td>The MSG_TYPE of the message the caller is interested in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9dd12dbdb263ed41b6fd849e1b7e0e2d"></a><!-- doxytag: member="net_helper.h::create_node" ref="a9dd12dbdb263ed41b6fd849e1b7e0e2d" args="(const char *IPaddr, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nodeID* <a class="el" href="net__helper_8h.html#a9dd12dbdb263ed41b6fd849e1b7e0e2d">create_node</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>IPaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new nodeID. </p>
<p>Create a new nodeID from a given IP address and port number. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IPaddr</td><td>The IP address in string form to be associated to the new nodeID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The port to be associated to the new nodeID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the new nodeID. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="chunk_sending_test_8c-example.html#a9">chunk_sending_test.c</a>, <a class="el" href="chunk_signaling_test_8c-example.html#a6">chunk_signaling_test.c</a>, <a class="el" href="topology_test_8c-example.html#a8">topology_test.c</a>, <a class="el" href="topology_test_attr_8c-example.html#a3">topology_test_attr.c</a>, and <a class="el" href="topology_test_th_8c-example.html#a7">topology_test_th.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a75c24f68a227ceca874aee06e35aef6f"></a><!-- doxytag: member="net_helper.h::net_helper_init" ref="a75c24f68a227ceca874aee06e35aef6f" args="(const char *IPaddr, int port, const char *config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nodeID* <a class="el" href="net__helper_8h.html#a75c24f68a227ceca874aee06e35aef6f">net_helper_init</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>IPaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize all needed internal parameters. </p>
<p>Initialize the parameters for the networking facilities and create a nodeID representing the caller. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IPaddr</td><td>The IP in string form to be associated to the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The port to be associated to the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Additional configuration options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a nodeID representing the caller, initialized with all the necessary data. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="chunk_sending_test_8c-example.html#a7">chunk_sending_test.c</a>, <a class="el" href="chunk_signaling_test_8c-example.html#a0">chunk_signaling_test.c</a>, <a class="el" href="topology_test_8c-example.html#a0">topology_test.c</a>, <a class="el" href="topology_test_attr_8c-example.html#a0">topology_test_attr.c</a>, and <a class="el" href="topology_test_th_8c-example.html#a0">topology_test_th.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad05d8fbd0811dd9cd8b9f527cc39e2fc"></a><!-- doxytag: member="net_helper.h::node_addr" ref="ad05d8fbd0811dd9cd8b9f527cc39e2fc" args="(const struct nodeID *s, char *addr, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="net__helper_8h.html#ad05d8fbd0811dd9cd8b9f527cc39e2fc">node_addr</a> </td>
          <td>(</td>
          <td class="paramtype">const struct nodeID *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give a string representation of a nodeID. </p>
<p>Give a string representation of a nodeID. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A pointer to the nodeID to be printed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>A pointer to the buffer where to write the address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length of the addr buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&gt;= 0 on success, or &lt; 0 on error (buffer too small) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="topology_test_8c-example.html#a7">topology_test.c</a>, <a class="el" href="topology_test_attr_8c-example.html#a1">topology_test_attr.c</a>, and <a class="el" href="topology_test_th_8c-example.html#a4">topology_test_th.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab16ff836fbed959c3030044d2310c43f"></a><!-- doxytag: member="net_helper.h::node_ip" ref="ab16ff836fbed959c3030044d2310c43f" args="(const struct nodeID *s, char *ip, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="net__helper_8h.html#ab16ff836fbed959c3030044d2310c43f">node_ip</a> </td>
          <td>(</td>
          <td class="paramtype">const struct nodeID *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give a string representation of the public IP belonging to the nodeID. </p>
<p>Serialize the public IP address of a given node and return it. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A pointer to the nodeID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ip</td><td>A pointer to the buffer where to store the ip address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length of the ip buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&gt;= 0 on success, or &lt; 0 on error (buffer too small) </dd></dl>

</div>
</div>
<a class="anchor" id="aa73adc34be2bbccd9db18cb0b9aff4b7"></a><!-- doxytag: member="net_helper.h::node_port" ref="aa73adc34be2bbccd9db18cb0b9aff4b7" args="(const struct nodeID *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="net__helper_8h.html#aa73adc34be2bbccd9db18cb0b9aff4b7">node_port</a> </td>
          <td>(</td>
          <td class="paramtype">const struct nodeID *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give the port number associated to the nodeID. </p>
<p>Return the port number of the nodeID </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A pointer to the nodeID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The port number belonging to the nodeID </dd></dl>

</div>
</div>
<a class="anchor" id="aaf5dae2ffb81eb6605c97c8f57af3e22"></a><!-- doxytag: member="net_helper.h::nodeid_cmp" ref="aaf5dae2ffb81eb6605c97c8f57af3e22" args="(const struct nodeID *s1, const struct nodeID *s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="net__helper_8h.html#aaf5dae2ffb81eb6605c97c8f57af3e22">nodeid_cmp</a> </td>
          <td>(</td>
          <td class="paramtype">const struct nodeID *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct nodeID *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two nodes and give some consistent ordering. This ordering should only be used for keeping lists ordered, it has no other meaning. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>The first nodeID to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The second nodeID to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1, 0 or 1, depending on the relation between s1 and s2. </dd></dl>

</div>
</div>
<a class="anchor" id="a92f4aa022ecb8b3d698da7d138fc64ad"></a><!-- doxytag: member="net_helper.h::nodeid_dump" ref="a92f4aa022ecb8b3d698da7d138fc64ad" args="(uint8_t *b, const struct nodeID *s, size_t max_write_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="net__helper_8h.html#a92f4aa022ecb8b3d698da7d138fc64ad">nodeid_dump</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct nodeID *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_write_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Serialize a nodeID in a byte array. </p>
<p>Serialize a nodeID in a byte array. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A pointer to the byte array that will contain the nodeID serialization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A pointer to the nodeID to be serialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_write_size</td><td>A number of bytes available in b </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes written in the buffer, or -1 if error </dd></dl>

</div>
</div>
<a class="anchor" id="ae8352797e9259af14c53a651feaab2cd"></a><!-- doxytag: member="net_helper.h::nodeid_dup" ref="ae8352797e9259af14c53a651feaab2cd" args="(struct nodeID *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nodeID* <a class="el" href="net__helper_8h.html#ae8352797e9259af14c53a651feaab2cd">nodeid_dup</a> </td>
          <td>(</td>
          <td class="paramtype">struct nodeID *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate a nodeID. </p>
<p>This function provides a duplicate of the given nodeID. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A pointer to the nodeID to be duplicated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the duplicate of the argument nodeID. </dd></dl>

</div>
</div>
<a class="anchor" id="a7191fee44ddba7c8421673a4a2be7659"></a><!-- doxytag: member="net_helper.h::nodeid_equal" ref="a7191fee44ddba7c8421673a4a2be7659" args="(const struct nodeID *s1, const struct nodeID *s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="net__helper_8h.html#a7191fee44ddba7c8421673a4a2be7659">nodeid_equal</a> </td>
          <td>(</td>
          <td class="paramtype">const struct nodeID *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct nodeID *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if two nodes are identical. </p>
<p>Test if two nodeIDs can be considered identical (where the definition of identity is implementation dependent). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>The first nodeID to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The second nodeID to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the two nodeID are identical or 0 if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="acbb39cd9f02b80f55cb9b4956f4d7e90"></a><!-- doxytag: member="net_helper.h::nodeid_free" ref="acbb39cd9f02b80f55cb9b4956f4d7e90" args="(struct nodeID *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="net__helper_8h.html#acbb39cd9f02b80f55cb9b4956f4d7e90">nodeid_free</a> </td>
          <td>(</td>
          <td class="paramtype">struct nodeID *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a nodeID. </p>
<p>Delete a nodeID and free the allocated resources. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A pointer to the nodeID to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="chunk_sending_test_8c-example.html#a11">chunk_sending_test.c</a>, <a class="el" href="chunk_signaling_test_8c-example.html#a5">chunk_signaling_test.c</a>, <a class="el" href="topology_test_8c-example.html#a5">topology_test.c</a>, <a class="el" href="topology_test_attr_8c-example.html#a5">topology_test_attr.c</a>, and <a class="el" href="topology_test_th_8c-example.html#a6">topology_test_th.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae3226bc9eb04a11867d8b5a03a0389eb"></a><!-- doxytag: member="net_helper.h::nodeid_undump" ref="ae3226bc9eb04a11867d8b5a03a0389eb" args="(const uint8_t *b, int *len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nodeID* <a class="el" href="net__helper_8h.html#ae3226bc9eb04a11867d8b5a03a0389eb">nodeid_undump</a> </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a nodeID structure from a serialized object. </p>
<p>Read from a properly filled byte array (</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="net__helper_8h.html#a92f4aa022ecb8b3d698da7d138fc64ad" title="Serialize a nodeID in a byte array.">nodeid_dump</a>) and build a new nodeID from its serialized representation in the buffer. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A pointer to the byte array containing the data to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes to be read from the buffer to build the new nodeID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the new nodeID. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a7b9f1b75209bb621e03b6bb64dbcac"></a><!-- doxytag: member="net_helper.h::recv_from_peer" ref="a6a7b9f1b75209bb621e03b6bb64dbcac" args="(const struct nodeID *local, struct nodeID **remote, uint8_t *buffer_ptr, int buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="net__helper_8h.html#a6a7b9f1b75209bb621e03b6bb64dbcac">recv_from_peer</a> </td>
          <td>(</td>
          <td class="paramtype">const struct nodeID *&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct nodeID **&#160;</td>
          <td class="paramname"><em>remote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive data from a remote peer. </p>
<p>This function transparently handles the receiving routines. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>A pointer to the nodeID representing the caller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">remote</td><td>The address to a pointer that has to be set to a new nodeID representing the sender peer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer_ptr</td><td>A pointer to the buffer containing the received data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer_size</td><td>The size of the data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of received bytes or -1 if some error occurred. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="chunk_sending_test_8c-example.html#a12">chunk_sending_test.c</a>, <a class="el" href="chunk_signaling_test_8c-example.html#a2">chunk_signaling_test.c</a>, <a class="el" href="topology_test_8c-example.html#a4">topology_test.c</a>, <a class="el" href="topology_test_attr_8c-example.html#a8">topology_test_attr.c</a>, and <a class="el" href="topology_test_th_8c-example.html#a5">topology_test_th.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adcdbaaa4ea0b0e78c6769f928568f488"></a><!-- doxytag: member="net_helper.h::send_to_peer" ref="adcdbaaa4ea0b0e78c6769f928568f488" args="(const struct nodeID *from, struct nodeID *to, const uint8_t *buffer_ptr, int buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="net__helper_8h.html#adcdbaaa4ea0b0e78c6769f928568f488">send_to_peer</a> </td>
          <td>(</td>
          <td class="paramtype">const struct nodeID *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct nodeID *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send data to a remote peer. </p>
<p>This function provides a transparently handles the sending routines. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>A pointer to the nodeID representing the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>A pointer to the nodeID representing the remote peer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_ptr</td><td>A pointer to the buffer containing the data to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>The length of the data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes sent or -1 if some error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="aba639b19170daf84c4b84e8f59eba6a3"></a><!-- doxytag: member="net_helper.h::wait4data" ref="aba639b19170daf84c4b84e8f59eba6a3" args="(const struct nodeID *n, struct timeval *tout, int *user_fds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="net__helper_8h.html#aba639b19170daf84c4b84e8f59eba6a3">wait4data</a> </td>
          <td>(</td>
          <td class="paramtype">const struct nodeID *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>user_fds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for newly arrived data. </p>
<p>Check if some data arrived for a given nodeID. It sets a timeout to return at most after a given time. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>A pointer to the nodeID representing the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout</td><td>A pointer to a timer to be used to set the waiting timeout. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_fds</td><td>A "-1 terminated" array of FDs to be monitored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if some data has arrived, 0 otherwise. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="chunkiser_test_8c-example.html#a0">chunkiser_test.c</a>, <a class="el" href="topology_test_8c-example.html#a3">topology_test.c</a>, and <a class="el" href="topology_test_attr_8c-example.html#a7">topology_test_attr.c</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri May 3 2013 10:18:23 for GRAPES by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
